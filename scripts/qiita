#!/usr/bin/env python

# -----------------------------------------------------------------------------
# Copyright (c) 2014--, The Qiita Development Team.
#
# Distributed under the terms of the BSD 3-clause License.
#
# The full license is in the file LICENSE, distributed with this software.
# -----------------------------------------------------------------------------
from __future__ import division, print_function

import errno
import socket
from datetime import datetime, timedelta
from os.path import join, abspath, dirname, basename
from future.utils import viewitems
from glob import glob
from time import sleep, ctime
from multiprocessing import active_children

import click
import tornado.httpserver
import tornado.ioloop
from psycopg2 import OperationalError

import qiita_db as qdb
from qiita_core.qiita_settings import qiita_config, r_client
from qiita_ware.ebi import EBISubmission
from qiita_ware.commands import submit_EBI as _submit_EBI


try:
    conn = qdb.sql_connection.SQLConnectionHandler()
except OperationalError:
    raise qdb.exceptions.QiitaDBConnectionError(
        "Database does not exist. See qiita-env make --help for more "
        "information")
else:
    del conn


@click.group()
def qiita():
    pass


@qiita.group()
def pet():
    pass


@pet.group(invoke_without_command=True)
@click.option('--build-docs/--no-build-docs', default=True, help="Controls "
              "whether the docs are built and moved to the 'doc' folder under "
              "the 'static' folder.")
def webserver(build_docs):
    if build_docs:
        import qiita_pet

        base = abspath(dirname(qiita_pet.__file__))
        sphinx_fp = join(base, 'support_files/doc/')
        cmd = 'make -C %s html' % sphinx_fp
        print('Building documentation ...')
        stdout, stderr, rv = qdb.processing_job._system_call(cmd)
        if rv != 0:
            raise click.ClickException(
                'Could not build documentation:\n'
                'Std output:%s\nStd error:%s' % (stdout, stderr))
        else:
            print('Documentation successfully built')


@qiita.group()
def db():
    pass


@qiita.group()
def maintenance():
    pass


@qiita.group()
def ware():
    pass


@qiita.group()
def plugins():
    pass


@ware.group()
def ebi():
    pass


# #############################################################################
# DB COMMANDS
# #############################################################################


@db.command()
@click.option('--owner', required=True,
              help="The email address of the owner of the study")
@click.option('--title', help="The title of the study", required=True)
@click.option('--info', type=click.File(mode='r'), required=True,
              help="filepath of file with study information in python "
              "config file format")
def load_study(owner, title, info):
    """Loads a study to the database"""
    study = qdb.commands.load_study_from_cmd(owner, title, info)
    click.echo("Study successfully added to the database with id %s"
               % study.id)


@db.command()
@click.option('--fp', required=True, type=click.Path(resolve_path=True,
              readable=True, exists=True), multiple=True,
              help='Path to the artifact files. This option can be used '
              'multiple times if there are multiple artifact files.')
@click.option('--fp_type', required=True, multiple=True, help='Describes the '
              'contents of the file. Pass one fp_type per fp.',
              type=click.Choice(qdb.util.get_filepath_types().keys()))
@click.option('--artifact_type', required=True, help="The artifact type",
              type=click.Choice(qdb.util.get_artifact_types().keys()))
@click.option('--prep_template', required=False,
              help="The prep template to which the artifact is attached",
              type=click.IntRange(1))
@click.option('--parents', required=False, multiple=True,
              help="The parent artifacts from which the new artifact has been "
                   "processed",
              type=click.IntRange(1))
@click.option('--dflt_params', required=False,
              help="The default parameter set used to process the new "
                   "artifact",
              type=click.IntRange(1))
@click.option('--required_params', required=False,
              help="JSON string containing the required parameters used to "
                   "process the new artifact",
              type=str)
@click.option('--optional_params', required=False,
              help="JSON string containing the optional parameters used to "
                   "process the new artifact, if different from the "
                   "defaults",
              type=str)
def load_artifact(fp, fp_type, artifact_type, prep_template, parents,
                  dflt_params, required_params, optional_params):
    """Loads an artifact to the database"""
    artifact = qdb.commands.load_artifact_from_cmd(
        fp, fp_type, artifact_type, prep_template=prep_template,
        parents=parents, dflt_params_id=dflt_params,
        required_params=required_params, optional_params=optional_params)
    click.echo("Artifact %s successfully created" % artifact.id)


@db.command()
@click.argument('fp', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True))
@click.option('--study', required=True, type=int,
              help='Associate the sample template with this study')
def load_sample_template(fp, study):
    """Loads a sample template to the database"""
    sample_temp = qdb.commands.load_sample_template_from_cmd(fp, study)
    click.echo("Sample template successfully added to the database with id %s"
               % sample_temp.id)


@db.command()
@click.argument('fp', required=True,
                type=click.Path(resolve_path=True, readable=True, exists=True))
@click.option('--study', required=True, type=int,
              help='Associate the prep template with this study')
@click.option('--data_type', required=True,
              type=click.Choice(qdb.util.get_data_types()),
              help="The data type of data")
def load_prep_template(fp, study, data_type):
    """Loads a sample template to the database"""
    prep_template = qdb.commands.load_prep_template_from_cmd(
        fp, study, data_type)
    click.echo("Prep template successfully added to the database with id %s"
               % prep_template.id)


# #############################################################################
# EBI COMMANDS
# #############################################################################

@ebi.command()
@click.option('--artifact-id', required=True, type=int)
@click.option('--action', type=click.Choice(EBISubmission.valid_ebi_actions),
              default='submit', help='The generated XML files will specify '
              'this "action", which controls how the EBI servers handle the '
              'metadata')
@click.option('--send/--no-send', default=False, help="Controls whether or "
              "not sequence files and metadata will actually be sent to EBI "
              "(default is to generate all the files, but not to send)")
def submit(artifact_id, action, send):
    _submit_EBI(artifact_id, action, send)


# #############################################################################
# MAINTENANCE COMMANDS
# #############################################################################

@maintenance.command()
@click.option('--time', required=True, type=int,
              help='The amount of time to show message, in hours')
@click.option('--message', required=True, type=str,
              help="Message to show users")
@click.option('--banner', is_flag=True,
              help="If set, show as site banner instead of a standard message")
def sysmessage(message, time, banner):
    if banner:
        r_client.setex('sysmessage', message, time)
    else:
        expires = datetime.now() + timedelta(seconds=(time * 60 * 60))
        qdb.util.add_system_message(message, expires)


@maintenance.command()
def clear_sysmessage():
    r_client.delete('sysmessage')
    qdb.util.clear_system_messages()


@maintenance.command()
def status():
    sys_status = r_client.get('sysmessage')

    if sys_status is None:
        click.echo("Site has no system message")
    else:
        click.echo("Site has system message:")
        click.echo(sys_status)
        click.echo(r_client.ttl('sysmessage'), "seconds remaining")


@maintenance.command()
@click.option('--n', required=False, type=click.IntRange(0, None), default=10,
              help="Number of most recent log entries to retrieve.",
              show_default=True)
def log(n):

    width = click.get_terminal_size()[0]

    template = width*"=" + "\nTime: {}\nMessage:\n{}\nInfo:{}\n"

    lines = []
    for e in qdb.logger.LogEntry.newest_records(n):

        info = []
        for i in e.info:
            for field, value in viewitems(i):
                info.append('{}:{}'.format(field, value))

        lines.append(template.format(e.time, e.msg, '\n'.join(info)))

    click.echo_via_pager('\n'.join(lines))

# #############################################################################
# WEBSERVER COMMANDS
# #############################################################################


@webserver.command()
@click.option('--port', required=False, type=int, help='Port where the '
              'webserver will start', default=21174)
# (cursive Q)iita = 21174 in 1337sp34k
@click.option('--master', is_flag=True,
              help="If set, update available plugins")
def start(port, master):
    from qiita_pet.webserver import Application
    from tornado.options import options, parse_command_line
    from tornado.ioloop import PeriodicCallback

    if master:
        # Deactivate all the plugins and only activate those that are currently
        # available in the config file folder
        qdb.software.Software.deactivate_all()
        _activate_or_update_plugins()

    # Create/repopulate the usernames key so we can do autocomplete for sharing
    r_client.delete('qiita-usernames')
    users = [email for email, name in qdb.user.User.iter()]
    if users:
        r_client.zadd('qiita-usernames', **{u: 0 for u in users})

    if qiita_config.log_dir:
        options.log_file_prefix = join(qiita_config.log_dir,
                                       'qiita_%d.log' % port)
        options.logging = 'debug'
        parse_command_line()
    ssl_options = {"certfile": qiita_config.certificate_file,
                   "keyfile": qiita_config.key_file}
    http_server = tornado.httpserver.HTTPServer(
        Application(), ssl_options=ssl_options)

    try:
        http_server.listen(port)
    except socket.error as e:
        if e.errno == errno.EADDRINUSE:
            raise ValueError(
                "Port %d is already in use. Please choose another port with "
                "--port." % port)
        else:
            raise
    base_url = qiita_config.base_url
    click.echo("Qiita started on %s:%d @ %s" % (base_url, port, ctime()))
    ioloop = tornado.ioloop.IOLoop.instance()

    if master:
        def callback_function():
            active_software = list(qdb.software.Software.iter())
            sdefinition = [s for s in active_software
                           if s.type == 'artifact definition']
            stransformation = [s for s in active_software
                               if s.type == 'artifact transformation']
            # registering definition artifacts
            for s in sdefinition:
                s.register_commands()
                # sleep is required as we don't want to saturate workers with
                # lots of requests
                sleep(1)
            # sleep to make sure that all definitions are done
            sleep(4)
            for s in stransformation:
                s.register_commands()
                # sleep is required as we don't want to saturate workers with
                # lots of requests
                sleep(1)

        ioloop.add_timeout(ioloop.time() + 0.5, callback_function)

    # Set a PeriodicCallback for cleaning up the threads
    # To understand why this is working as expected, check the multiprocessing
    # documentation https://docs.python.org/2/library/multiprocessing.html
    # 1200000 == 20 min
    PeriodicCallback(lambda: active_children(), 1200000).start()

    ioloop.start()

# #############################################################################
# PLUGIN COMMANDS
# #############################################################################


def _activate_or_update_plugins(update=False):
    """Activates/updates the plugins

    Parameters
    ----------
    update : bool, optional
        If True will update the plugins. Otherwise will activate them.
        Default: False.
    """
    conf_files = glob(join(qiita_config.plugin_dir, "*.conf"))
    label = "{} plugin (%s/{}): %s... ".format(
        "Updating" if update else "\tLoading", len(conf_files))
    for i, fp in enumerate(conf_files):
        click.echo(label % (i + 1, basename(fp)), nl=False)
        s = qdb.software.Software.from_file(fp, update=update)
        if not update:
            s.activate()
        click.echo("Ok")


@plugins.command()
def update():
    """Updates the plugins in the database"""
    _activate_or_update_plugins(update=True)


if __name__ == '__main__':
    qiita()
